<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="https://ajax.googleapis.com/ajax/libs/threejs/r69/three.min.js"></script>
    	<script src='js/threex.text.js'></script>
		<script src="fonts/droid/droid_serif_bold.typeface.js"></script>
		<script src="http://brangerbriz.net/labs/threejs_playGnd/js/Detector.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<style>

.enter {
	display: none;
	position: absolute;
	width: 320px;
	height: 200px;
	top: 50%;
	left: 50%;
	margin-top: -200px;
	margin-left: -160px;
	text-align: center;
	vertical-align: middle;

}

.enter a {
	color: #fff;
	font-family: sans-serif;
	text-decoration: none;
	font-size: 100%;
	z-index: 666;
	cursor: pointer;

}

</style>

					<div class="enter">
								<a href="https://tnasty.herokuapp.com/">ENTER</a>
					</div>


		<script>

		$(function() {

				$('.enter').hide();

				$(document).on({ 'touchend click' :  function(){

						$('.enter').fadeIn("slow");


				} });



		});



			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, scene, renderer;
			var geometry, material, mesh;

				var mouseX = 0, mouseY = 0;

			windowHalfX = window.innerWidth / 2,
			windowHalfY = window.innerHeight / 2


			function setup() {

				container = document.createElement( 'div' );
            document.body.appendChild( container );

				var W = window.innerWidth, H = window.innerHeight;
				renderer = new THREE.WebGLRenderer( { preserveDrawingBuffer: true } );
				renderer.autoClearColor = false;
				renderer.setSize( W, H );
				document.body.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				//

				window.addEventListener( 'resize', onWindowResize, false );

				camera = new THREE.PerspectiveCamera( 50, W/H, 1, 10000 );
				camera.position.z = 500;



				scene = new THREE.Scene();

	function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}












			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length === 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}



					  meshOne  = new THREEx.Text('#TNASTY#')
					  meshOne.scale.multiplyScalar(100)
					  scene.add(meshOne)


			 if(window.outerWidth < 700) {

			 	meshOne.scale.multiplyScalar(1/3);

			 }


	/*
				    map = THREE.ImageUtils.loadTexture('tnasty.jpg');
					geometry = new THREE.PlaneGeometry(10, 10, 4, 4);
					material = new THREE.MeshBasicMaterial({shading: THREE.FlatShading, color: 0xffffff, map: map});
					mesh = new THREE.Mesh(geometry, material);
					map.wrapS = map.wrapT = THREE.RepeatWrapping;
					map.repeat.set( 1, 1 );
					mesh.scale.x = mesh.scale.y = mesh.scale.z = 100;
					mesh.position.z = -300;
					scene.add(mesh);

*/

			}





function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) * 4;
				mouseY = ( event.clientY - windowHalfY ) * 4;

			}




			function draw() {

				requestAnimationFrame( draw );

	/*			var randomColor = Math.random() * 0xffffff;
				mesh.material.color.setHex(randomColor);

		        mesh.position.x = Math.sin( Date.now() * 0.0009 ) * 300;
				mesh.rotation.z = Date.now() * 0.0005;

*/

 				camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				camera.lookAt( scene.position );


				renderer.render( scene, camera );

			}

			setup();
			draw();




		</script>

















	</body>
</html>
